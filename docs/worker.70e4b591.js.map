{"mappings":"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","sources":["src/mandel/mandel.ts","src/app/worker.ts"],"names":["get_hex_color","color_1","color_2","n","dr","dg","db","r","g","b","calc_mandelbrot","total_width","total_height","pixel_length","max_iter","top","left","bot","right","pixel_num","is_black","y","xs","x","z_re","z_im","z_re_sq","z_im_sq","c_re","c_im","iter","ys","uint32_view","Uint32Array","fill","Uint8ClampedArray","buffer","pixel_bytes","c_re_0","c_im_0","dre","dim","pixel_idx","rgba","config","mod","calc","ev","tasks","data","bufs","task","$fbcd6a1607d2355a46eabfc38af500b2$export$default","px_width","px_height","px_ax_len","iter_max","bytes","push","self","postMessage","onmessage"],"version":3,"file":"worker.70e4b591.js.map","sourcesContent":["// Convert rgb values to hex value\nfunction rgb_to_hex (r: number, g: number, b: number) {\n\treturn 0xff000000 | ((r << 16) | (g << 8) | b)\n}\nconst color_fractal = [ 80, 242, 196 ]\nconst color_infinity = [ 11, 18, 43 ]\n\nconst get_hex_color = get_color_fn(color_infinity, color_fractal)\n\nfunction get_color_fn (color_1: number[], color_2: number[]) {\n\treturn function (n: number) {\n\t\t// if (n < 0.5 && n > 0.5) {\n\t\t// \tn = n * n * 2\n\t\t// }\n\t\tconst dr = color_2[0] - color_1[0]\n\t\tconst dg = color_2[1] - color_1[1]\n\t\tconst db = color_2[2] - color_1[2]\n\t\tconst [ r, g, b ] = [\n\t\t\tdr * n + color_1[0],\n\t\t\tdg * n + color_1[1],\n\t\t\tdb * n + color_1[2]\n\t\t]\n\t\t/* return rgb_to_hex(b, g, r) */\n\t\treturn [ r, g, b, 0xff ]\n\t}\n}\n\nfunction coord_to_idx (width, x, y) {\n\treturn x + y * width\n}\n\nfunction set_red (width, x, y, byte_array) {\n\tconst idx = coord_to_idx(width, x, y)\n\tbyte_array[idx] = 0xff\n\tbyte_array[idx + 1] = 0x00\n\tbyte_array[idx + 2] = 0x00\n\tbyte_array[idx + 3] = 0xff\n}\n\nfunction calc_mandelbrot (\n\ttotal_width: number,\n\ttotal_height: number,\n\tpixel_length: number,\n\tmax_iter: number,\n\ttop: number,\n\tleft: number,\n\tbot: number,\n\tright: number\n) {\n\t/* number of pixels is pixels between vertex coordinates */\n\tconst pixel_num = (right - left) * (bot - top)\n\n\t// OPTIMIZATION LOOKAHEAD\n\tlet is_black = true\n\tconst step = 3\n\t// outer columns (constant x inside loop, iterate through all columns in column)\n\tfor (let y = top; y < bot; y += step) {\n\t\tconst xs = [ left, right - 1 ]\n\t\tfor (const x of xs) {\n\t\t\t/* initial z = 0.0 + 0.0i */\n\t\t\tlet z_re = 0.0\n\t\t\tlet z_im = 0.0\n\t\t\t/* initial squares are both 0.0 */\n\t\t\tlet z_re_sq = 0.0\n\t\t\tlet z_im_sq = 0.0\n\t\t\t/* c constant is determined using pixel coordinate */\n\t\t\tconst c_re = (x + 0.5 - total_width / 2.0) * pixel_length\n\t\t\tconst c_im = (total_height / 2.0 - y + 0.5) * pixel_length\n\t\t\t/* do max_iter iterations per pixel coordinate */\n\t\t\tlet iter = 0\n\t\t\t/* while sum of z is below infinity boundary 4 */\n\t\t\twhile (z_re_sq + z_im_sq <= 4.0) {\n\t\t\t\tif (iter == max_iter) break\n\t\t\t\tz_im = z_re * z_im\n\t\t\t\tz_im += z_im\n\t\t\t\tz_im += c_im\n\t\t\t\tz_re = z_re_sq - z_im_sq + c_re\n\t\t\t\tz_re_sq = z_re * z_re\n\t\t\t\tz_im_sq = z_im * z_im\n\t\t\t\titer += 1\n\t\t\t}\n\t\t\t// if max_iter surpassed -> pixel is in Mandelbrot set\n\t\t\tif (iter < max_iter) {\n\t\t\t\tis_black = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// outer columns (constant y inside loop, iterate through all columns in column)\n\tfor (let x = left; x < right; x += step) {\n\t\tconst ys = [ top, bot - 1 ]\n\t\tfor (const y of ys) {\n\t\t\t/* initial z = 0.0 + 0.0i */\n\t\t\tlet z_re = 0.0\n\t\t\tlet z_im = 0.0\n\t\t\t/* initial squares are both 0.0 */\n\t\t\tlet z_re_sq = 0.0\n\t\t\tlet z_im_sq = 0.0\n\t\t\t/* c constant is determined using pixel coordinate */\n\t\t\tconst c_re = (x + 0.5 - total_width / 2.0) * pixel_length\n\t\t\tconst c_im = (total_height / 2.0 - y + 0.5) * pixel_length\n\t\t\t/* do max_iter iterations per pixel coordinate */\n\t\t\tlet iter = 0\n\t\t\t/* while sum of z is below infinity boundary 4 */\n\t\t\twhile (z_re_sq + z_im_sq <= 4.0) {\n\t\t\t\tif (iter == max_iter) break\n\t\t\t\tz_im = z_re * z_im\n\t\t\t\tz_im += z_im\n\t\t\t\tz_im += c_im\n\t\t\t\tz_re = z_re_sq - z_im_sq + c_re\n\t\t\t\tz_re_sq = z_re * z_re\n\t\t\t\tz_im_sq = z_im * z_im\n\t\t\t\titer += 1\n\t\t\t}\n\t\t\t// if max_iter surpassed -> pixel is in Mandelbrot set\n\t\t\tif (iter < max_iter) {\n\t\t\t\tis_black = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\t// if no outline pixel violated the iteration check\n\tif (is_black) {\n\t\t// return array of black pixels\n\t\tconst uint32_view = new Uint32Array(pixel_num).fill(0xff000000)\n\t\treturn new Uint8ClampedArray(uint32_view.buffer)\n\t}\n\n\t// MAIN (full) ITERATION\n\tconst pixel_bytes = new Uint8ClampedArray(pixel_num * 4)\n\t// MINI OPTIMIZATION\n\t// complex constants\n\tconst c_re_0 = (0 + 0.5 - total_width / 2) * pixel_length\n\tconst c_im_0 = (total_height / 2 - 0 + 0.5) * pixel_length\n\tconst dre = (1 + 0.5 - total_width / 2) * pixel_length - c_re_0\n\tconst dim = (total_height / 2 - 1 + 0.5) * pixel_length - c_im_0\n\tlet pixel_idx = 0\n\t/* loop through pixels in task */\n\tfor (let y = top; y < bot; y++) {\n\t\tfor (let x = left; x < right; x++) {\n\t\t\t/* initial z = 0.0 + 0.0i */\n\t\t\tlet z_re = 0.0\n\t\t\tlet z_im = 0.0\n\t\t\t/* initial squares are both 0.0 */\n\t\t\tlet z_re_sq = 0.0\n\t\t\tlet z_im_sq = 0.0\n\t\t\t/* c constant is determined using pixel coordinate */\n\t\t\tconst c_re = c_re_0 + dre * x\n\t\t\tconst c_im = c_im_0 + dim * y\n\t\t\t/* do max_iter iterations per pixel coordinate */\n\t\t\tlet iter = 0\n\t\t\t/* while sum of z is below infinity boundary 4 */\n\t\t\twhile (z_re_sq + z_im_sq <= 4.0) {\n\t\t\t\tif (iter == max_iter) break\n\t\t\t\tz_im = z_re * z_im\n\t\t\t\tz_im += z_im\n\t\t\t\tz_im += c_im\n\t\t\t\tz_re = z_re_sq - z_im_sq + c_re\n\t\t\t\tz_re_sq = z_re * z_re\n\t\t\t\tz_im_sq = z_im * z_im\n\t\t\t\titer += 1\n\t\t\t}\n\t\t\t/* if max iterations were passed, pixel is within mandelbrot set */\n\t\t\t/* pixels within are black 0xff000000, pixels outside are colored relative to number of iterations */\n\t\t\tconst rgba =\n\t\t\t\titer >= max_iter\n\t\t\t\t\t? [ 0x00, 0x00, 0x00, 0xff ]\n\t\t\t\t\t: get_hex_color(iter / max_iter * 30)\n\t\t\tpixel_bytes[pixel_idx * 4] = rgba[0]\n\t\t\tpixel_bytes[pixel_idx * 4 + 1] = rgba[1]\n\t\t\tpixel_bytes[pixel_idx * 4 + 2] = rgba[2]\n\t\t\tpixel_bytes[pixel_idx * 4 + 3] = rgba[3]\n\t\t\tpixel_idx += 1\n\t\t}\n\t}\n\n\treturn pixel_bytes\n}\n\nexport default calc_mandelbrot\n","import { Config } from './config'\nimport { Task } from './queue'\nimport mandel_ts from '../mandel/mandel'\n\ninterface Message {\n\tconfig: Config\n\tmod: WebAssembly.Module\n}\n\nlet config: Config\nlet mod: WebAssembly.Module\n\nfunction calc(ev: MessageEvent) {\n\tconst tasks: Task[] = ev.data\n\tconst bufs: ArrayBuffer[] = []\n\tfor (const task of tasks) {\n\t\tconst pixel_bytes = mandel_ts(\n\t\t\tconfig.px_width,\n\t\t\tconfig.px_height,\n\t\t\ttask.px_ax_len,\n\t\t\tconfig.iter_max,\n\t\t\ttask.top,\n\t\t\ttask.left,\n\t\t\ttask.bot,\n\t\t\ttask.right\n\t\t)\n\t\ttask.bytes = pixel_bytes\n\t\tbufs.push(pixel_bytes.buffer)\n\t}\n\t// @ts-ignore\n\tself.postMessage(tasks, bufs)\n}\n\nself.onmessage = function handle_first_message(ev: MessageEvent) {\n\t// assign global config\n\t;[ config, mod ] = ev.data\n\t// replace message handler\n\tself.onmessage = calc\n}\n\n// // instantiate wasm module\n// WebAssembly.instantiate(data.module_buffer, {}).then(function (instance) {\n// \tconst m = (instance as unknown) as WebAssembly.Instance\n// \tcalc_mandelbrot_c = m.exports.calc_mandelbrot as mandelbrot_c\n// \tconst memory = m.exports.memory as WebAssembly.Memory\n\n// \tconst bytes = config.pixel_num * 4\n// \tconst page = 1024 * 64\n// \tconst extra_pages = Math.ceil(bytes / page)\n\n// \tmemory.grow(extra_pages)\n\n// \tconst base_ptr = calc_mandelbrot_c(\n// \t\tconfig.real_width,\n// \t\tconfig.real_height,\n// \t\tconfig.pixel_length,\n// \t\tconfig.iterations,\n// \t\tworker_num,\n// \t\tworker_idx\n// \t)\n// \tconst pixels = new Uint32Array(memory.buffer.slice(base_ptr, base_ptr + bytes))\n// \t// @ts-ignore\n// \tself.postMessage(pixels)\n// })\n"]}